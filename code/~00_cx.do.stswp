/*==============================================================================
Project    : School Spending – F-33 and INDFIN Integration
File       : 00_cx.do
Purpose    : Construct unified district panels and crosswalks linking NCES F-33, INDFIN, 
              and GRF district identifiers.
Author     : Myles Owens
Institution: Hoover Institution, Stanford University
Date       : 2025-10-27
-------------------------------------------------------------------------------
Description:
1. Build and clean F-33 and INDFIN district by year panels.
2. Generate canonical crosswalks between LEAID, GOVID, and GRF IDs.
3. Produce merged datasets for downstream event-study and panel analysis.

Global Path:
    global SchoolSpending "C:\Users\maowens\OneDrive - Stanford\school\git"

Inputs:
    - $SchoolSpending\data\raw\nces\build_f33_in_dir\*.sas7bdat
    - $SchoolSpending\data\raw\indfin\build_indfin_in_dir\
    - $SchoolSpending\data\raw\GRF69\DS0001\03515-0001-Data.txt
    - $SchoolSpending\data\ALLids.csv

Outputs:
    - f33_panel.dta
    - indfin_panel.dta
    - canon_crosswalk.dta
    - f33_indfin_grf_canon.dta

Notes:
    - Flags anomalous values but retains them for traceability.
    - Canonical ID logic prioritizes valid, non-junk identifiers.
    - Ensure `$SchoolSpending` global is correctly defined before execution.
==============================================================================*/

*/


*** ---------------------------------------------------------------------------
*** 1. Build f33 panel (NCES Data)
*** ---------------------------------------------------------------------------


clear
set more off
cd "$SchoolSpending\data\raw\nces\build_f33_in_dir"

* Identify all F-33 raw SAS files
local files : dir "." files "*.sas7bdat"

* Loop through and convert each SAS file to Stata format
foreach f of local files {
    disp "Processing `f'"
    
    import sas using "`f'", clear

    local outname = subinstr("`f'", ".sas7bdat", ".dta", .)
    save "`outname'", replace
}

*** Append all F-33 files into one panel
local files : dir "." files "*.dta"
tempfile base

local first = 1
foreach f of local files {
    disp "Processing `f'"

    * Try to pull year (example: "sdf92.dta" → 1992)
    local shortyr = substr("`f'", 4, 2)
    local year = cond(real("`shortyr'") < 50, 2000 + real("`shortyr'"), 1900 + real("`shortyr'"))

    use LEAID CENSUSID NAME V33 TOTALEXP using "`f'", clear
    gen year = `year'

    if `first' {
        save `base'
        local first = 0
    }
    else {
        append using `base'
        save `base', replace
    }
}

use `base', clear


cd "$SchoolSpending\data"

* Flag anomalies (keep for later inspection)
gen bad_pop   = (V33 <= 0)        // zero or negative pop
label var bad_pop "Zero or negative pop"
label var bad_pop "Flag: zero or negative population"
gen bad_exp   = (TOTALEXP < 0)    // negative expenditure
label var bad_exp "Flag: negative expenditure"



* Calculate per-pupil expenditure (in #1000s)
gen pp_exp = .
replace pp_exp = TOTALEXP/1000 / V33 
label var pp_exp "Per-pupil expenditure"

* Extract 9-digit GOVID from 14-digit CENSUSID
gen str9 GOVID = substr(CENSUSID,1,9)
save f33_panel, replace




*** ---------------------------------------------------------------------------
*** 2. Build indifn panel (Census Individual Finance)
*** ---------------------------------------------------------------------------

***Settings

local years 67 70 71 72 73 74 75 76 77 78 79 ///
            80 81 82 83 84 85 86 87 88 89   ///
            90 91   // 68 & 69 skipped

local inDir  "$SchoolSpending\data\raw\indfin\build_indfin_in_dir"
local outDir "$SchoolSpending\data\raw\indfin\build_indfin_out_dir"

*Variables to retain
local keepvars ///
    sortcode year4 id idchanged statecode typecode county name ///
    population elemeductotalexp totalexpenditure totaleductotalexp
	
* Clean and standardize each yearly INDFIN dataset
foreach y of local years {
    di as txt "→ trimming `y'"
    use "`inDir'/indfin`y'a.dta", clear
    keep if typecode == 5                     // focus on school districts
    keep `keepvars'
    save "`outDir'/f`y'.dta", replace
}

* Stack all cleaned years into one panel
local first : word 1 of `years'
use "`outDir'/f`first'.dta", clear

foreach y of local years {
    if "`y'" == "`first'" continue
    append using "`outDir'/f`y'.dta"
}

save "`outDir'/indfin_panel_1967_1991_clean.dta", replace
di as result "✓ INDFIN panel (1967‑1991) complete."

* Create standard 9-digit GOVID
gen str9 GOVID = string(id, "%09.0f")
cd "$SchoolSpending\data"

gen pp_exp = .
replace pp_exp = totalexpenditure/population
label var pp_exp "Per-pupil expenditure"
save indfin_panel, replace




*** ---------------------------------------------------------------------------
*** 3. Import Master ID Files (F33 IDs, INDFIN IDs, GRF)
*** ---------------------------------------------------------------------------

*** --- F33 ID crosswalk
clear
set more off
cd "$SchoolSpending\data\raw\nces\build_f33_in_dir"

local files : dir "." files "*.sas7bdat"

foreach f of local files {
    disp "Processing `f'"
    
    import sas using "`f'", clear

    local outname = subinstr("`f'", ".sas7bdat", ".dta", .)
    save "`outname'", replace
}

* Append all yearly ID files
local files : dir "." files "*.dta"
tempfile base

local first = 1
foreach f of local files {
    disp "Processing `f'"

    * Try to pull year (example: "sdf92.dta" → 1992)
    local shortyr = substr("`f'", 4, 2)
    local year = cond(real("`shortyr'") < 50, 2000 + real("`shortyr'"), 1900 + real("`shortyr'"))

    use LEAID CENSUSID NAME using "`f'", clear
    gen year = `year'

    if `first' {
        save `base'
        local first = 0
    }
    else {
        append using `base'
        save `base', replace
    }
}

use `base', clear


*Data
cd "$SchoolSpending\data"
gen str9 GOVID = substr(CENSUSID,1,9)
save f33_id, replace


*** --- INDFIN Master ID list
clear
set more off
cd "$SchoolSpending\data"
import delimited using "$SchoolSpending\data\raw\indfin\ALLids.csv"
gen str9 GOVID = string(id, "%09.0f")
keep if typecode == 5  // school districts only
drop id idchanged typecode county censusreg statecode ///
version population jacketunit zerodata
save indfin_id, replace



*** --- GRF (Geographic Reference File) 1969
clear 
set more off
local dfile "$SchoolSpending\data\raw\GRF69\DS0001\03515-0001-Data.txt"

*** import fixed-width ASCII [ICPSR layout]
infix ///
    /* numeric codes */                                                        ///
    byte  stc70  1-2      /* 1970 state code 01–56  */                         ///
    byte  stc60  3-4      /* 1960 state code       */                           ///
    int   coc70  5-7      /* 1970 county code      */                           ///
    int   ctabu  8-10     /* county of population  */                           ///
    byte  cencc  11       /* central-county flag   */                           ///
    int   mcd    12-14    /* minor civil division  */                           ///
    int   placc  15-18    /* place code            */                           ///
    byte  platc  19       /* place-type code       */                           ///
    /* strings (SPSS marks with (A)) */                                         ///
    str2  plasc  20-21    /* place-size code       */                           ///
    str1  stcac  22-22    /* consolidated-area code*/                           ///
    str4  smsa   23-26    /* SMSA code             */                           ///
    /* more numeric */                                                          ///
    int   urbca  27-30    /* urbanized-area code   */                           ///
    int   trac   31-34    /* tracted-area code     */                           ///
    byte  uniap  35       /* universal area prefix */                           ///
    int   uniac  36-40    /* universal area code   */                           ///
    /* strings again */                                                         ///
    str2  steac  41-42    /* state economic area   */                           ///
    str3  ecosc  43-45    /* economic sub-region   */                           ///
    str1  cebdc  46-46    /* CBD flag              */                           ///
    str30 arnam  47-76    /* area name             */                           ///
    /* back to numeric (ICPSR dropped Gov. ID; BTC starts here) */              ///
    long  btc    77-80    /* basic tract code      */                           ///
    int   tsc    81-82    /* tract suffix code     */                           ///
    byte  blgc   83       /* block-group code      */                           ///
    str5  endc   84-88    /* enum.-district code   */                           ///
    str1  urrc   89-89    /* urban/rural flag      */                           ///
    int   warc   90-91    /* ward code             */                           ///
    int   codc   92-93    /* congressional district*/                           ///
    long  houc   94-100   /* housing count         */                           ///
    long  popc   101-108  /* population count      */                           ///
    long  sdc    109-113  /* school-district code  */                           ///
    byte  sdtc   114-114  /* school-district type  */                           ///
    int   aduc   115-116  /* admin-unit code       */                           ///
    int   perc   117-119  /* percent equivalent    */                           ///
using "`dfile'", clear


*** Labels
label variable stc70  "1970 State Code"
label variable stc60  "1960 State Code"
label variable coc70  "1970 County Code"
label variable ctabu  "County of Population"
label variable cencc  "Central County Code"
label variable mcd    "Minor Civil Division"
label variable placc  "Place Code"
label variable platc  "Place Type Code"
label variable plasc  "Place Size Code"
label variable stcac  "Std. Consolidated Area Code"
label variable smsa   "SMSA Code"
label variable urbca  "Urbanized Area Code"
label variable trac   "Tracted Area Code"
label variable uniap  "Universal Area Prefix"
label variable uniac  "Universal Area Code"
label variable steac  "State Economic Area Code"
label variable ecosc  "Economic Subregion Code"
label variable cebdc  "Central Business District Code"
label variable arnam  "Area Name"
label variable btc    "Basic Tract Code"
label variable tsc    "Tract Suffix Code"
label variable blgc   "Block Group Code"
label variable endc   "Enumeration District Code"
label variable urrc   "Urban/Rural Class Code"
label variable warc   "Ward Code"
label variable codc   "Congressional District Code"
label variable houc   "Housing Count"
label variable popc   "Population Count"
label variable sdc    "School District Code"
label variable sdtc   "School District Type Code"
label variable aduc   "Administrative Unit Code"


* Clean and construct geographic identifiers
*** Basic Tract Code (btc) should be 4 digits; if missing, treat as 0000
*** Tract-Suffix Code (tsc) should be 2 digits; if missing, treat as 00  
replace btc = 0  if missing(btc)
replace tsc = 0 if tsc == .
gen no_tract = 0
replace no_tract = 1 if missing(trac)

* Build composite identifiers
gen str4 btc_str = string(btc,"%04.0f")
gen str2 tsc_str = string(tsc,"%02.0f")
gen str5 sdc_str = string(sdc,"%05.0f")


*** Now build the 11-char tract ID safely
gen str11 tract70 = ///
    string(stc70,"%02.0f") + string(coc70,"%03.0f") + btc_str + tsc_str
gen str13 gisjoin2 = ///
	string(stc70,"%02.0f") + "0" + string(coc70,"%03.0f") + "0" + btc_str + tsc_str 
gen str7 LEAID = string(stc70,"%02.0f") + sdc_str
	
*** Drop the two-digit suffix only when it equals "00"
replace gisjoin2 = substr(gisjoin2, 1, 11) if substr(gisjoin2, -2, 2) == "00"

*** one row per LEAID with its district-type flag (sdtc)
keep LEAID arnam 
duplicates tag LEAID, gen(dup)
bysort LEAID: keep if _n == 1
drop if missing(LEAID)
keep LEAID arnam
save grf_id, replace







/*==============================================================================
ACTIONS CONTEXT (place this block immediately before Actions 1–5)

Goal:
  Build a canonical district-year panel where the universe is LEAIDs that appear
  in BOTH GRF and F-33. Canonicalize LEAID↔GOVID, map INDFIN by GOVID into that
  universe, and keep provenance and conflict flags.

Upstream artifacts already created in this file:
  - f33_panel.dta
      Vars assumed: LEAID (str), CENSUSID (str14), NAME, V33 (pop), TOTALEXP,
                    year (int), GOVID (str9 from substr(CENSUSID,1,9)),
                    pp_exp (TOTALEXP/1000/V33)
  - indfin_panel.dta
      Vars assumed: GOVID (str9, named GOVID or normalized later to GOVID_raw),
                    year OR year4, population, totalexpenditure,
                    pp_exp (totalexpenditure/population)
  - f33_id.dta
      Vars assumed: LEAID (str), CENSUSID (str14), NAME, year, GOVID (str9)
  - indfin_id.dta
      Vars assumed: GOVID (str9), typecode filtered to school districts
      Note: indfin_id has NO LEAID
  - grf_id.dta
      Vars assumed: LEAID (str), arnam

Hard constraints:
  - Usable universe is LEAID ∈ (GRF ∩ F-33). If a LEAID is not in both, drop it.
  - A GOVID may be junk ("M", "N", missing). Junk GOVIDs do NOT invalidate a LEAID.
  - INDFIN rows are usable only if their GOVID maps (via F-33 pairs) to a usable LEAID.

Definitions:
  - Junk GOVID: missing or inlist("M","N").
  - rel_type (computed on NON-junk pairs only):
      1 = 1:1
      2 = 1:M (LEAID→multiple GOVIDs)
      3 = M:1 (GOVID→multiple LEAIDs)
      4 = M:M
      0 = LEAID-only row with junk GOVID (tag only)

Canonization policy:
  - For each LEAID, pick GOVID_canon = the NON-junk GOVID with the most F-33 year
    coverage. Tie-break by alphabetical GOVID.
  - For each GOVID, pick LEAID by the same coverage rule (used only to route INDFIN).
  - Preserve junk rows for tagging, but exclude them from multiplicity logic.

Provenance and conflict flags in final panel:
  - has_f33, has_indfin
  - pp_exp_f33, pp_exp_indfin, pp_exp (chosen)
  - source_pick_pp_exp ∈ {"f33","indfin","both_equal"}
  - conflict_pp_exp = 1 if both present and not equal

Intermediate files created by Actions 1–5 (tempfiles during run):
  - usableL        : LEAIDs in GRF ∩ F-33
  - pairs_full     : LEAID–GOVID pairs from F-33 (with junk flag)
  - covpairs       : LEAID–GOVID non-junk with n_years coverage (from F-33)
  - canon_cov      : LEAID → GOVID_canon (coverage-based)
  - govid2canon    : GOVID_raw → (LEAID, GOVID_canon) by coverage
  - panel_union    : union skeleton before final save

Final outputs saved to disk:
  - f33_indfin_grf_canon.dta  (canonical panel with provenance and conflicts)

Known pitfalls handled below:
  - INDFIN has no LEAID: routed via GOVID using govid2canon.
  - year naming mismatch in INDFIN: normalize to year4 if needed.
  - Duplicates: always de-dup by key before merges that assume 1:1 keys.

Sanity checks printed by Actions:
  - Size of GRF, F-33, and their LEAID intersection.
  - Multiplicity distribution of LEAID↔GOVID pairs.
  - Share of INDFIN GOVIDs that map into the usable universe.
  - Final union row count, distinct LEAIDs, and conflict rate.

After this block, code actions 1-5
==============================================================================*/
*** =========================
*** ACTIONS 1–5 (DRAFT)
*Below is a draft version of solving this provlem taht i did not complete that i want you to


*** ---------------------------------------------------------------------------
*** ACTIONS 1–5: Canonicalize IDs and build unified panel (per spec)
*** ---------------------------------------------------------------------------

cd "$SchoolSpending\data"

*=============================================================================*
* 1) Universe: LEAID ∈ (GRF ∩ F-33)
*=============================================================================*
tempfile grfL f33L usableL

use grf_id, clear
keep LEAID
drop if missing(LEAID)
duplicates drop
gen byte in_grf = 1
save `grfL'

use f33_id, clear
keep LEAID
drop if missing(LEAID)
duplicates drop
gen byte in_f33 = 1
save `f33L'

use `f33L', clear
merge 1:1 LEAID using `grfL'
keep if _merge==3
drop _merge
tempfile usableL
save `usableL'

display as result "Universe (LEAID in GRF ∩ F-33): " _N " districts"

*=============================================================================*
* 2) Pairs from F-33: LEAID–GOVID by year, junk flag, multiplicity, coverage
*=============================================================================*
tempfile pairs_full covpairs pairtypes

use f33_id, clear
merge m:1 LEAID using `usableL', keep(3) nogen   // enforce usable universe
rename GOVID GOVID_raw
drop if missing(LEAID)

* one row per LEAID–GOVID–year
keep LEAID GOVID_raw year
duplicates drop LEAID GOVID_raw year, force
gen byte is_govid_junk = missing(GOVID_raw) | inlist(GOVID_raw,"M","N")
save `pairs_full'

* multiplicity types on NON-junk pairs only
preserve
    keep if is_govid_junk==0
    keep LEAID GOVID_raw
    duplicates drop
    bysort LEAID: gen n_govid = _N
    bysort GOVID_raw: gen n_leaid = _N
    gen byte rel_type = .
    replace rel_type = 1 if n_govid==1 & n_leaid==1
    replace rel_type = 2 if n_govid>1  & n_leaid==1    // 1:M (LEAID→GOVID)
    replace rel_type = 3 if n_govid==1 & n_leaid>1     // M:1 (GOVID→LEAID)
    replace rel_type = 4 if n_govid>1  & n_leaid>1     // M:M
    capture label drop rel
    label define rel 1 "1:1" 2 "1:M (LEAID→GOVID)" 3 "M:1 (GOVID→LEAID)" 4 "M:M" 0 "LEAID w/ junk GOVID"
    label values rel_type rel
    save `pairtypes'
restore

* year coverage counts for NON-junk LEAID–GOVID pairs
preserve
    keep if is_govid_junk==0
    duplicates drop LEAID GOVID_raw year, force
    collapse (count) n_years=year, by(LEAID GOVID_raw)
    save `covpairs'
restore

*=============================================================================*
* 3) Canonicalization (coverage-based with tie-break alphabetical)
*    - LEAID → GOVID_canon
*    - GOVID → LEAID_canon
*=============================================================================*
tempfile canon_L2G canon_G2L govid2canon

* LEAID → GOVID_canon
use `covpairs', clear
gsort LEAID -n_years GOVID_raw
by LEAID: gen byte pick = _n==1
keep if pick
drop pick
rename GOVID_raw GOVID_canon
keep LEAID GOVID_canon n_years
bys LEAID: gen n_years_canon = n_years
drop n_years
save `canon_L2G'

* GOVID → LEAID_canon
use `covpairs', clear
gsort GOVID_raw -n_years LEAID
by GOVID_raw: gen byte pick = _n==1
keep if pick
drop pick
rename GOVID_raw GOVID
rename LEAID LEAID_canon
keep GOVID LEAID_canon
save `canon_G2L'

* GOVID_raw → (LEAID_canon, GOVID_canon via its LEAID_canon)
use `canon_G2L', clear
rename LEAID_canon LEAID
merge 1:1 LEAID using `canon_L2G', nogen
rename LEAID LEAID_canon
save `govid2canon'

*=============================================================================*
* 4) Canonical crosswalk artifact (for auditing)
*     One row per unique LEAID×GOVID pair seen in F-33 (junk kept for tag)
*=============================================================================*
use `pairs_full', clear
keep LEAID GOVID_raw
duplicates drop
rename GOVID_raw GOVID

merge m:1 LEAID using `canon_L2G', nogen
merge m:1 GOVID using `canon_G2L', nogen

merge m:1 LEAID GOVID using `covpairs'
replace n_years = 0 if missing(n_years)

merge m:1 LEAID GOVID using `pairtypes'
gen byte is_govid_junk = missing(GOVID) | inlist(GOVID,"M","N")
replace rel_type = 0 if missing(rel_type) & is_govid_junk==1
label values rel_type rel

order LEAID GOVID GOVID_canon LEAID_canon n_years rel_type is_govid_junk
save canon_crosswalk, replace
display as result "Saved: canon_crosswalk.dta"

* quick sanity table
tab rel_type

*=============================================================================*
* 5) Build merged panel (route INDFIN via govid2canon, align scales)
*=============================================================================*

*----------- F-33 side (restricted to usable LEAIDs) -----------
tempfile f33_core
use f33_panel, clear
rename year year4
merge m:1 LEAID using `usableL', keep(3) nogen
* attach GOVID_canon for convenience
merge m:1 LEAID using `canon_L2G', nogen
* consistent per-pupil: thousands of dollars per pupil
gen double pp_exp_f33 = TOTALEXP/1000 / V33
gen byte has_f33 = !missing(TOTALEXP)
keep LEAID year4 V33 TOTALEXP pp_exp_f33 has_f33 GOVID_canon
duplicates drop LEAID year4, force
save `f33_core'

*----------- INDFIN side (route by GOVID→LEAID_canon, keep only usable LEAIDs) -----------
tempfile ind_core
use indfin_panel, clear
* ensure year variable is year4 (your trimmed files already have year4)
capture confirm variable year4
if _rc {
    capture confirm variable year
    if !_rc rename year year4
}
* map to canon LEAID and attach that LEAID's GOVID_canon
merge m:1 GOVID using `govid2canon'
drop if _merge==1 | _merge==2   // drop rows that don't map to a LEAID_canon
drop _merge
rename LEAID_canon LEAID
merge m:1 LEAID using `usableL', keep(3) nogen  // enforce usable universe
merge m:1 LEAID using `canon_L2G', nogen        // get GOVID_canon for this LEAID
* consistent per-pupil: thousands of dollars per pupil
gen double pp_exp_indfin = totalexpenditure/1000 / population
gen byte has_indfin = !missing(totalexpenditure)
keep LEAID year4 population totalexpenditure pp_exp_indfin has_indfin GOVID_canon
duplicates drop LEAID year4, force
save `ind_core'

*----------- Union + provenance/conflicts -----------
use `f33_core', clear
merge 1:1 LEAID year4 using `ind_core'
* merge code: 1=only f33, 2=only indfin, 3=both
gen byte has_f33    = (inlist(_merge,1,3) & has_f33==1)
gen byte has_indfin = (inlist(_merge,2,3) & has_indfin==1)

* pick per-pupil (favor F-33 if both present and unequal; mark equals)
gen double pp_exp = .
gen str11 source_pick_pp_exp = ""
gen byte conflict_pp_exp = 0

replace conflict_pp_exp = (has_f33 & has_indfin & abs(pp_exp_f33 - pp_exp_indfin) > 1e-6)
replace source_pick_pp_exp = "both_equal" if has_f33 & has_indfin & conflict_pp_exp==0
replace source_pick_pp_exp = "f33"        if has_f33 & (has_indfin==0 | conflict_pp_exp==1)
replace source_pick_pp_exp = "indfin"     if has_f33==0 & has_indfin

replace pp_exp = pp_exp_f33 if inlist(source_pick_pp_exp,"f33","both_equal")
replace pp_exp = pp_exp_indfin if source_pick_pp_exp=="indfin"

drop _merge

* attach GRF name for convenience
merge m:1 LEAID using grf_id, keep(1 3) nogen

order LEAID year4 GOVID_canon pp_exp pp_exp_f33 pp_exp_indfin source_pick_pp_exp conflict_pp_exp ///
      V33 TOTALEXP population totalexpenditure arnam has_f33 has_indfin

label var GOVID_canon          "Canonical GOVID (by coverage within LEAID)"
label var pp_exp               "Per-pupil exp (thousands of $), chosen"
label var pp_exp_f33           "F-33 per-pupil exp (thousands of $)"
label var pp_exp_indfin        "INDFIN per-pupil exp (thousands of $)"
label var source_pick_pp_exp   "Chosen source: f33/indfin/both_equal"
label var conflict_pp_exp      "1 if both present and ≠"
label var V33                  "F-33 population"
label var TOTALEXP             "F-33 total expenditure"
label var population           "INDFIN population"
label var totalexpenditure     "INDFIN total expenditure"
label var arnam                "GRF Area Name"
label var has_f33              "Row has F-33"
label var has_indfin           "Row has INDFIN"

save f33_indfin_grf_canon, replace
display as result "Saved: f33_indfin_grf_canon.dta"

*=============================================================================*
* QA prints the adults in the room would ask for
*=============================================================================*
* Multiplicity summary (non-junk)
use canon_crosswalk, clear
tab rel_type

* Share of INDFIN GOVIDs mapping into usable universe
quietly {
    preserve
        use indfin_panel, clear
        keep GOVID
        drop if missing(GOVID) | inlist(GOVID,"M","N")
        duplicates drop
        count
        scalar s_total_govid = r(N)
        merge m:1 GOVID using `govid2canon', keep(3) nogen
        count
        scalar s_mapped_govid = r(N)
    restore
}
display as result "INDFIN GOVIDs mapped into usable universe: " ///
    %9.0gc s_mapped_govid " of " %9.0gc s_total_govid " (" %4.1f (100*s_mapped_govid/s_total_govid) "%)"

* Final panel size and conflict rate
use f33_indfin_grf_canon, clear
count
scalar s_rows = r(N)
contract LEAID
count
scalar s_leaid = r(N)
summ conflict_pp_exp
display as result "Final rows: " %9.0gc s_rows " | Distinct LEAIDs: " %9.0gc s_leaid
display as result "Conflict rate (pp_exp): " %5.2f (100*r(mean)) "%"






*** ---------------------------------------------------------------------------
*** 4. Simple Merger NO canon IDs
*** ---------------------------------------------------------------------------

use grf_id, clear
merge 1:m LEAID using f33_id
keep if _merge==3
drop _merge CENSUSID 

* 0) Drop exact duplicate rows for the same LEAID–GOVID combo
gsort LEAID GOVID -year
bysort LEAID GOVID: keep if _n==1

*==============================================================*
* 1) Build unique LEAID×GOVID crosswalk and label relationship
*    Types: 1:1, 1:M (LEAID→GOVID), 1:M (GOVID→LEAID), M:M
*==============================================================*
preserve
    keep LEAID GOVID
    drop if missing(LEAID) 
	drop if LEAID == "M"
	drop if LEAID == "N"
    bysort LEAID: gen n_govid = _N       // distinct GOVIDs for this LEAID
    bysort GOVID: gen n_leaid = _N       // distinct LEAIDs for this GOVID
    gen byte rel_type = .
    replace rel_type = 1 if n_govid==1 & n_leaid==1
    replace rel_type = 2 if n_govid>1  & n_leaid==1    // 1:M (LEAID→GOVID)
    replace rel_type = 3 if n_govid==1 & n_leaid>1     // 1:M (GOVID→LEAID)
    replace rel_type = 4 if n_govid>1  & n_leaid>1     // M:M
    label define rel 1 "1:1" 2 "1:M (LEAID→GOVID)" 3 "1:M (GOVID→LEAID)" 4 "M:M"
    label values rel_type rel
    tempfile pairtypes
    save `pairtypes'
restore

* Attach the relationship label to every observation in your panel
merge m:1 LEAID GOVID using `pairtypes'
drop _merge
* Optional sanity check
tab rel_type


keep if rel_type ==1
save f33_grf,replace

use f33_grf, clear
merge 1:m GOVID using indfin_id
drop if missing(GOVID)
drop if _merge == 2
*save indfin_clean,replace
keep LEAID GOVID
save f33_indfin_grf_11,replace


*panel

use f33_indfin_grf_11, clear
merge 1:m LEAID GOVID using f33_panel
keep if _merge == 3
drop _merge
duplicates drop LEAID GOVID year pp_exp, force
rename year year4
save f33_grf_panel, replace

use f33_indfin_grf_11, clear
merge 1:m GOVID using indfin_panel
drop if _merge == 2
save indfin_grf_panel, replace


append using f33_grf_panel
duplicates drop LEAID GOVID year4, force

save f33_indfin_grf_canon, replace


/*
*** ---------------------------------------------------------------------------
*** 4. BUILD CROSSWALK: LEAID × GOVID
*** ---------------------------------------------------------------------------

*=============================*
* Start
*=============================*
use f33_id, clear
drop CENSUSID

* 0) Drop exact duplicate rows for the same LEAID–GOVID combo
gsort LEAID GOVID -year
bysort LEAID GOVID: keep if _n==1

*==============================================================*
* 1) Build unique LEAID×GOVID crosswalk and label relationship
*    Types: 1:1, 1:M (LEAID→GOVID), 1:M (GOVID→LEAID), M:M
*==============================================================*
preserve
    keep LEAID GOVID
    drop if missing(LEAID) 
	drop if LEAID == "M"
	drop if LEAID == "N"
	duplicates drop LEAID GOVID, force
    bysort LEAID: gen n_govid = _N       // distinct GOVIDs for this LEAID
    bysort GOVID: gen n_leaid = _N       // distinct LEAIDs for this GOVID
    gen byte rel_type = .
    replace rel_type = 1 if n_govid==1 & n_leaid==1
    replace rel_type = 2 if n_govid>1  & n_leaid==1    // 1:M (LEAID→GOVID)
    replace rel_type = 3 if n_govid==1 & n_leaid>1     // 1:M (GOVID→LEAID)
    replace rel_type = 4 if n_govid>1  & n_leaid>1     // M:M
    label define rel 1 "1:1" 2 "1:M (LEAID→GOVID)" 3 "1:M (GOVID→LEAID)" 4 "M:M"
    label values rel_type rel
    tempfile pairtypes
    save `pairtypes'
restore

* Attach the relationship label to every observation in your panel
merge m:1 LEAID GOVID using `pairtypes'

* Optional sanity check
tab rel_type









*==============================================================*
* 2) Canonical IDs (deterministic, prefer valid over junk)
*    - GOVID_canon: prefer non-junk GOVID; if only junk exists → missing
*    - LEAID_canon: exclude junk LEAID entirely (unusable)
*    Ties break by smallest code.
*==============================================================*

*-------------------------------*
* Canonical GOVID for each LEAID
*-------------------------------*
preserve
    keep LEAID GOVID
    drop if missing(LEAID) | inlist(LEAID,"M","N")   // LEAID must be usable
    duplicates drop LEAID GOVID, force

    contract LEAID GOVID                              // _freq
    gen byte is_govid_junk = missing(GOVID) | inlist(GOVID,"M","N")

    * Sort: within LEAID, prefer non-junk (0), then higher freq, then smallest code
    gsort LEAID is_govid_junk -_freq GOVID
    by LEAID: gen byte pick = _n==1
    keep if pick
    drop pick

    * If all GOVIDs were junk for a LEAID, the top one is still junk.
    * We'll keep it for inspection, but blank it out so canon never equals "M"/"N".
    replace GOVID = "" if is_govid_junk
    drop is_govid_junk

    rename GOVID GOVID_canon
    keep LEAID GOVID_canon
    tempfile canon_leaid
    save `canon_leaid'
restore
merge m:1 LEAID using `canon_leaid', nogen

*-------------------------------*
* Canonical LEAID for each GOVID
*-------------------------------*
preserve
    keep LEAID GOVID
    drop if missing(LEAID) | inlist(LEAID,"M","N")   // junk LEAID unusable
    duplicates drop LEAID GOVID, force

    contract GOVID LEAID
    * Here we can keep junk GOVIDs in the pool; we're choosing a LEAID for each GOVID.
    gsort GOVID -_freq LEAID
    by GOVID: gen byte pick = _n==1
    keep if pick
    drop pick

    rename LEAID LEAID_canon
    keep GOVID LEAID_canon
    tempfile canon_govid
    save `canon_govid'
restore
merge m:1 GOVID using `canon_govid', nogen

* Optional QA flags
gen byte canon_govid_is_junk = inlist(GOVID_canon,"M","N") | missing(GOVID_canon)
gen byte canon_leaid_is_junk = inlist(LEAID_canon,"M","N") | missing(LEAID_canon)
drop _merge
save canon_crosswalk, replace
* If you actually want to collapse onto canon IDs:
* replace GOVID = GOVID_canon if !missing(GOVID_canon)
* replace LEAID = LEAID_canon if !missing(LEAID_canon)

*** ---------------------------------------------------------------------------
*** 5. APPLY CROSSWALK: Merge Canonical IDs into INDFIN + F33 + GRF
*** ---------------------------------------------------------------------------

*-------------------------------*
* Merge into indfin
*-------------------------------*
use canon_crosswalk,clear
drop if missing(GOVID)
keep if rel_type ==1
merge 1:m GOVID using indfin_panel
drop if _merge == 1
drop _merge
tempfile indfin_11
save `indfin_11',replace


use canon_crosswalk,clear
drop if missing(GOVID) | inlist(GOVID, "N", "M")
keep if rel_type ==3
duplicates drop GOVID, force
merge 1:m GOVID using `indfin_11'
drop if _merge == 1
drop _merge
tempfile indfin_11_1M
drop year n_govid n_leaid rel_type GOVID_canon
replace LEAID = LEAID_canon if !missing(LEAID_canon)   
tempfile indfin_11_1M           
save `indfin_11_1M',replace

use canon_crosswalk,clear
drop if missing(GOVID) | inlist(GOVID, "N", "M")
keep if rel_type ==2
merge 1:m GOVID using `indfin_11_1M'
drop if _merge == 1
drop _merge
replace GOVID = GOVID_canon if !missing(GOVID_canon)  
drop year n_govid n_leaid rel_type GOVID_canon LEAID_canon
tempfile indfin_11_1M_M1
save `indfin_11_1M_M1',replace

*-------------------------------*
* Merge into F33
*-------------------------------*
use canon_crosswalk,clear
duplicates drop LEAID, force
drop year
merge 1:m LEAID using f33_panel
replace LEAID = LEAID_canon if !missing(LEAID_canon)   
replace GOVID = GOVID_canon if !missing(GOVID_canon)  

rename year year4
rename V33 population
rename TOTALEXP totalexpenditure
drop n_govid n_leaid rel_type GOVID_canon LEAID_canon
append using  `indfin_11_1M_M1'
drop _merge
save f33_indfin_canon, replace

*-------------------------------*
* Canonize and merge GRF into full-panel
*-------------------------------*
use canon_crosswalk,clear
duplicates drop LEAID, force
drop year
merge 1:m LEAID using grf_id
replace LEAID = LEAID_canon if !missing(LEAID_canon)   
drop GOVID GOVID_canon _merge
duplicates drop LEAID, force
merge 1:m LEAID using f33_indfin_canon
keep if _merge == 3
drop arnam _merge


*/